{"version":3,"sources":["config/constants/endpoints.ts","config/constants/info.ts","state/info/queries/pools/chartData.ts","state/info/queries/pools/transactions.ts","state/info/queries/tokens/chartData.ts","state/info/queries/tokens/transactions.ts","state/info/queries/tokens/priceData.ts","state/info/queries/tokens/poolsForToken.ts","state/info/hooks.ts","views/Info/utils/infoQueryHelpers.ts","state/info/queries/helpers.ts","views/Info/hooks/useBlocksFromTimestamps.ts","state/info/types.ts","views/Info/utils/infoDataHelpers.ts","state/info/queries/protocol/overview.ts","state/info/queries/protocol/chart.ts","state/info/queries/protocol/transactions.ts","state/info/queries/pools/topPools.ts","state/info/queries/pools/poolData.ts","views/Info/hooks/useElaPrices.ts","state/info/queries/tokens/tokenData.ts","state/info/queries/tokens/topTokens.ts","state/info/updaters.ts"],"names":["process","REACT_APP_GRAPH_API_PROFILE","REACT_APP_GRAPH_API_PREDICTION","REACT_APP_GRAPH_API_LOTTERY","REACT_APP_SNAPSHOT_VOTING_API","SNAPSHOT_BASE_URL","REACT_APP_SNAPSHOT_BASE_URL","BRIDGE_FAUCET_API","INFO_CLIENT","BLOCKS_CLIENT","MINIMUM_SEARCH_CHARACTERS","WEEKS_IN_YEAR","TOTAL_FEE","LP_HOLDERS_FEE","PCS_V2_START","ONE_DAY_UNIX","ONE_HOUR_SECONDS","ITEMS_PER_INFO_TABLE_PAGE","TOKEN_BLACKLIST","getPoolChartData","skip","address","a","query","gql","request","startTime","pairDayDatas","data","map","mapPairDayData","error","console","fetchPoolChartData","fetchChartData","POOL_TRANSACTIONS","fetchPoolTransactions","mints","mapMints","burns","mapBurns","swaps","mapSwaps","getTokenChartData","tokenDayDatas","mapDayData","fetchTokenChartData","TOKEN_TRANSACTIONS","fetchTokenTransactions","mints0","mintsAs0","mints1","mintsAs1","burns0","burnsAs0","burns1","burnsAs1","swaps0","swapsAs0","swaps1","swapsAs1","getPriceSubqueries","tokenAddress","blocks","block","timestamp","number","priceQueryConstructor","subqueries","fetchTokenPriceData","interval","startTimestamp","endTimestamp","getUnixTime","Date","timestamps","time","push","getBlocksFromTimestamps","length","multiQuery","prices","tokenPrices","Object","keys","forEach","priceKey","split","derivedELA","parseFloat","priceUSD","tokenPriceIndex","findIndex","tokenPrice","elaPrice","sort","b","parseInt","formattedHistory","i","open","close","high","low","POOLS_FOR_TOKEN","fetchPoolsForToken","blacklist","addresses","asToken0","concat","asToken1","p","id","useProtocolData","protocolData","useSelector","state","info","protocol","overview","dispatch","useDispatch","useCallback","updateProtocolData","useProtocolChartData","chartData","updateProtocolChartData","useProtocolTransactions","transactions","transactionsData","updateProtocolTransactions","useAllPoolData","pools","byAddress","useUpdatePoolData","updatePoolData","useAddPoolKeys","poolAddresses","addPoolKeys","usePoolDatas","allPoolData","addNewPoolKeys","untrackedAddresses","reduce","accum","includes","useEffect","filter","pool","usePoolChartData","useState","setError","fetch","fetchError","updatePoolChartData","poolAddress","usePoolTransactions","updatePoolTransactions","useAllTokenData","tokens","useUpdateTokenData","updateTokenData","useAddTokenKeys","tokenAddresses","addTokenKeys","useTokenDatas","allTokenData","addNewTokenKeys","useMemo","token","useTokenData","isAddress","usePoolsForToken","poolsForToken","addTokenPoolAddresses","useTokenChartData","updateTokenChartData","useTokenPriceData","timeWindow","priceData","oldestTimestampFetched","oldestFetchedTimestamp","utcCurrentTime","startOfHour","sub","fetchingError","updateTokenPriceData","secondsInterval","useTokenTransactions","updateTokenTransactions","queryConstructor","endpoint","skipCount","fetchedData","allFound","end","subqueriesSlice","slice","result","getDeltaTimestamps","startOfMinute","subDays","subWeeks","mint","type","TransactionType","MINT","hash","sender","to","token0Symbol","pair","token0","symbol","token1Symbol","token1","token0Address","token1Address","amountUSD","amountToken0","amount0","amountToken1","amount1","burn","BURN","swap","SWAP","from","amount0In","amount0Out","amount1In","amount1Out","tokenDayData","date","volumeUSD","dailyVolumeUSD","liquidityUSD","totalLiquidityUSD","pairDayData","reserveUSD","getEntityDayDatas","chartEntries","formattedDayDatas","dayData","dayOrdinal","toFixed","availableDays","firstAvailableDayData","latestLiquidityUSD","toString","values","getBlockSubqueries","blocksQueryConstructor","sortDirection","sortingFunction","key","useBlocksFromTimestamps","setBlocks","timestampsString","JSON","stringify","blocksString","undefined","fetchData","timestampsArray","parse","getAmountChange","valueNow","valueBefore","getPercentChange","getChangeForPeriod","valueOnePeriodAgo","valueTwoPeriodsAgo","currentPeriodAmount","previousPeriodAmount","getLpFeesAndApr","volumeUSDWeek","totalFees24h","totalFees7d","lpFees24h","lpFees7d","lpApr7d","Infinity","getOverviewData","formatGlideFactoryResponse","rawGlideFactory","totalTransactions","totalVolumeUSD","useFetchProtocolData","fetchState","setFetchState","t24","t48","blockError","block24","block48","error24","data24","error48","data48","anyError","overviewData","glideFactories","overviewData24","overviewData48","allDataAvailable","volumeUSDChange","liquidityUSDChange","txCount","txCountChange","GLIDE_DAY_DATAS","getOverviewChartData","glideDayDatas","useFetchGlobalChartData","overviewChartData","setOverviewChartData","GLOBAL_TRANSACTIONS","fetchTopTransactions","fetchTopPools","timestamp24hAgo","useTopPoolAddresses","topPoolAddresses","setTopPoolAddresses","POOL_AT_BLOCK","blockString","addressesString","join","fetchPoolData","block24h","block48h","block7d","block14d","parsePoolData","pairs","poolData","reserve0","reserve1","token0Price","token1Price","t24h","t48h","t7d","t14d","formattedPoolData","now","formattedPoolData24h","oneDayAgo","formattedPoolData48h","twoDaysAgo","formattedPoolData7d","oneWeekAgo","formattedPoolData14d","twoWeeksAgo","formatted","current","oneDay","twoDays","week","twoWeeks","volumeUSDChangeWeek","liquidityToken0","liquidityToken1","name","allBlocksAvailable","ELA_PRICES","fetchElaPrices","blockWeek","elaPrices","twoDay","oneWeek","TOKEN_AT_BLOCK","fetchTokenData","parseTokenData","tokenData","derivedUSD","tradeVolumeUSD","totalLiquidity","useFetchedTokenDatas","setPrices","tWeek","useElaPrices","parsed","parsed24","parsed48","parsed7d","parsed14d","liquidityUSDOneDayAgo","liquidityToken","priceUSDOneDay","priceUSDWeek","priceUSDChange","priceUSDChangeWeek","exists","fetchTopTokens","t","useTopTokenAddresses","topTokenAddresses","setTopTokenAddresses","ProtocolUpdater","setProtocolData","fetchedProtocolData","updateChartData","fetchedChartData","chartError","updateTransactions","PoolUpdater","unfetchedPoolAddresses","poolDataError","poolDatas","TokenUpdater","updateTokenDatas","unfetchedTokenAddresses","tokenDataError","tokenDatas"],"mappings":"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","file":"static/js/1.8db9f0e8.chunk.js","sourcesContent":["export const GRAPH_API_PROFILE = process.env.REACT_APP_GRAPH_API_PROFILE\nexport const GRAPH_API_PREDICTION = process.env.REACT_APP_GRAPH_API_PREDICTION\nexport const GRAPH_API_LOTTERY = process.env.REACT_APP_GRAPH_API_LOTTERY\nexport const SNAPSHOT_VOTING_API = process.env.REACT_APP_SNAPSHOT_VOTING_API\nexport const SNAPSHOT_BASE_URL = process.env.REACT_APP_SNAPSHOT_BASE_URL\nexport const SNAPSHOT_API = `${SNAPSHOT_BASE_URL}/graphql`\nexport const SNAPSHOT_HUB_API = `${SNAPSHOT_BASE_URL}/api/message`\nexport const BITQUERY_API = 'https://graphql.bitquery.io'\n\nexport const BRIDGE_FAUCET_API = 'https://api.glidefinance.io'\n\nexport const INFO_CLIENT = 'https://api.glidefinance.io/subgraphs/name/glide/exchange'\nexport const BLOCKS_CLIENT = 'https://api.glidefinance.io/subgraphs/name/glide/blocks'\n// export const BLOCKS_CLIENT = 'https://elastos-graph.elk.finance/subgraphs/name/elkfinance/elastos-blocks'\n","export const MINIMUM_SEARCH_CHARACTERS = 2\n\nexport const WEEKS_IN_YEAR = 52.1429\n\nexport const TOTAL_FEE = 0.0025\nexport const LP_HOLDERS_FEE = 0.0005\nexport const TREASURY_FEE = 0.002\nexport const BUYBACK_FEE = 0\n\nexport const PCS_V2_START = 1635919200 // November 3, 2021, 12:00:00 AM\nexport const ONE_DAY_UNIX = 86400 // 24h * 60m * 60s\nexport const ONE_HOUR_SECONDS = 3600\n\nexport const ITEMS_PER_INFO_TABLE_PAGE = 10\n\n// These tokens are either incorrectly priced or have some other issues that spoil the query data\n// None of them present any interest as they have almost 0 daily trade volume\nexport const TOKEN_BLACKLIST = [\"0x\"]\n","import { request, gql } from 'graphql-request'\nimport { INFO_CLIENT } from 'config/constants/endpoints'\nimport { ChartEntry } from 'state/info/types'\nimport { PCS_V2_START } from 'config/constants/info'\nimport { PairDayDatasResponse } from '../types'\nimport { mapPairDayData, fetchChartData } from '../helpers'\n\nconst getPoolChartData = async (skip: number, address: string): Promise<{ data?: ChartEntry[]; error: boolean }> => {\n  try {\n    const query = gql`\n      query pairDayDatas($startTime: Int!, $skip: Int!, $address: Bytes!) {\n        pairDayDatas(\n          first: 1000\n          skip: $skip\n          where: { pairAddress: $address, date_gt: $startTime }\n          orderBy: date\n          orderDirection: asc\n        ) {\n          date\n          dailyVolumeUSD\n          reserveUSD\n        }\n      }\n    `\n    const { pairDayDatas } = await request<PairDayDatasResponse>(INFO_CLIENT, query, {\n      startTime: PCS_V2_START,\n      skip,\n      address,\n    })\n    const data = pairDayDatas.map(mapPairDayData)\n    return { data, error: false }\n  } catch (error) {\n    console.error('Failed to fetch pool chart data', error)\n    return { error: true }\n  }\n}\n\nconst fetchPoolChartData = async (address: string): Promise<{ data?: ChartEntry[]; error: boolean }> => {\n  return fetchChartData(getPoolChartData, address)\n}\n\nexport default fetchPoolChartData\n","import { request, gql } from 'graphql-request'\nimport { INFO_CLIENT } from 'config/constants/endpoints'\nimport { Transaction } from 'state/info/types'\nimport { MintResponse, SwapResponse, BurnResponse } from 'state/info/queries/types'\nimport { mapMints, mapBurns, mapSwaps } from 'state/info/queries/helpers'\n/**\n * Transactions of the given pool, used on Pool page\n */\nconst POOL_TRANSACTIONS = gql`\n  query poolTransactions($address: Bytes!) {\n    mints(first: 35, orderBy: timestamp, orderDirection: desc, where: { pair: $address }) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      to\n      amount0\n      amount1\n      amountUSD\n    }\n    swaps(first: 35, orderBy: timestamp, orderDirection: desc, where: { pair: $address }) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      from\n      amount0In\n      amount1In\n      amount0Out\n      amount1Out\n      amountUSD\n    }\n    burns(first: 35, orderBy: timestamp, orderDirection: desc, where: { pair: $address }) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      sender\n      amount0\n      amount1\n      amountUSD\n    }\n  }\n`\n\ninterface TransactionResults {\n  mints: MintResponse[]\n  swaps: SwapResponse[]\n  burns: BurnResponse[]\n}\n\nconst fetchPoolTransactions = async (address: string): Promise<{ data?: Transaction[]; error: boolean }> => {\n  try {\n    const data = await request<TransactionResults>(INFO_CLIENT, POOL_TRANSACTIONS, {\n      address,\n    })\n    const mints = data.mints.map(mapMints)\n    const burns = data.burns.map(mapBurns)\n    const swaps = data.swaps.map(mapSwaps)\n    return { data: [...mints, ...burns, ...swaps], error: false }\n  } catch (error) {\n    console.error(`Failed to fetch transactions for pool ${address}`, error)\n    return {\n      error: true,\n    }\n  }\n}\n\nexport default fetchPoolTransactions\n","import { request, gql } from 'graphql-request'\nimport { INFO_CLIENT } from 'config/constants/endpoints'\nimport { ChartEntry } from 'state/info/types'\nimport { PCS_V2_START } from 'config/constants/info'\nimport { TokenDayDatasResponse } from '../types'\nimport { mapDayData, fetchChartData } from '../helpers'\n\nconst getTokenChartData = async (skip: number, address: string): Promise<{ data?: ChartEntry[]; error: boolean }> => {\n  try {\n    const query = gql`\n      query tokenDayDatas($startTime: Int!, $skip: Int!, $address: Bytes!) {\n        tokenDayDatas(\n          first: 1000\n          skip: $skip\n          where: { token: $address, date_gt: $startTime }\n          orderBy: date\n          orderDirection: asc\n        ) {\n          date\n          dailyVolumeUSD\n          totalLiquidityUSD\n        }\n      }\n    `\n    const { tokenDayDatas } = await request<TokenDayDatasResponse>(INFO_CLIENT, query, {\n      startTime: PCS_V2_START,\n      skip,\n      address,\n    })\n    const data = tokenDayDatas.map(mapDayData)\n    return { data, error: false }\n  } catch (error) {\n    console.error('Failed to fetch token chart data', error)\n    return { error: true }\n  }\n}\n\nconst fetchTokenChartData = async (address: string): Promise<{ data?: ChartEntry[]; error: boolean }> => {\n  return fetchChartData(getTokenChartData, address)\n}\n\nexport default fetchTokenChartData\n","import { request, gql } from 'graphql-request'\nimport { INFO_CLIENT } from 'config/constants/endpoints'\nimport { Transaction } from 'state/info/types'\nimport { MintResponse, SwapResponse, BurnResponse } from 'state/info/queries/types'\nimport { mapMints, mapBurns, mapSwaps } from 'state/info/queries/helpers'\n\n/**\n * Data to display transaction table on Token page\n */\nconst TOKEN_TRANSACTIONS = gql`\n  query tokenTransactions($address: Bytes!) {\n    mintsAs0: mints(first: 10, orderBy: timestamp, orderDirection: desc, where: { token0: $address }) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      to\n      amount0\n      amount1\n      amountUSD\n    }\n    mintsAs1: mints(first: 10, orderBy: timestamp, orderDirection: desc, where: { token0: $address }) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      to\n      amount0\n      amount1\n      amountUSD\n    }\n    swapsAs0: swaps(first: 10, orderBy: timestamp, orderDirection: desc, where: { token0: $address }) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      from\n      amount0In\n      amount1In\n      amount0Out\n      amount1Out\n      amountUSD\n    }\n    swapsAs1: swaps(first: 10, orderBy: timestamp, orderDirection: desc, where: { token1: $address }) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      from\n      amount0In\n      amount1In\n      amount0Out\n      amount1Out\n      amountUSD\n    }\n    burnsAs0: burns(first: 10, orderBy: timestamp, orderDirection: desc, where: { token0: $address }) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      sender\n      amount0\n      amount1\n      amountUSD\n    }\n    burnsAs1: burns(first: 10, orderBy: timestamp, orderDirection: desc, where: { token1: $address }) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      sender\n      amount0\n      amount1\n      amountUSD\n    }\n  }\n`\n\ninterface TransactionResults {\n  mintsAs0: MintResponse[]\n  mintsAs1: MintResponse[]\n  swapsAs0: SwapResponse[]\n  swapsAs1: SwapResponse[]\n  burnsAs0: BurnResponse[]\n  burnsAs1: BurnResponse[]\n}\n\nconst fetchTokenTransactions = async (address: string): Promise<{ data?: Transaction[]; error: boolean }> => {\n  try {\n    const data = await request<TransactionResults>(INFO_CLIENT, TOKEN_TRANSACTIONS, {\n      address,\n    })\n    const mints0 = data.mintsAs0.map(mapMints)\n    const mints1 = data.mintsAs1.map(mapMints)\n\n    const burns0 = data.burnsAs0.map(mapBurns)\n    const burns1 = data.burnsAs1.map(mapBurns)\n\n    const swaps0 = data.swapsAs0.map(mapSwaps)\n    const swaps1 = data.swapsAs1.map(mapSwaps)\n\n    return { data: [...mints0, ...mints1, ...burns0, ...burns1, ...swaps0, ...swaps1], error: false }\n  } catch (error) {\n    console.error(`Failed to fetch transactions for token ${address}`, error)\n    return {\n      error: true,\n    }\n  }\n}\n\nexport default fetchTokenTransactions\n","import { getUnixTime } from 'date-fns'\nimport { gql } from 'graphql-request'\nimport { getBlocksFromTimestamps } from 'views/Info/hooks/useBlocksFromTimestamps'\nimport { multiQuery } from 'views/Info/utils/infoQueryHelpers'\nimport { PriceChartEntry } from 'state/info/types'\nimport { INFO_CLIENT } from 'config/constants/endpoints'\n\nconst getPriceSubqueries = (tokenAddress: string, blocks: any) =>\n  blocks.map(\n    (block: any) => `\n      t${block.timestamp}:token(id:\"${tokenAddress}\", block: { number: ${block.number} }) { \n        derivedELA\n      }\n      b${block.timestamp}: bundle(id:\"1\", block: { number: ${block.number} }) { \n        elaPrice\n      }\n    `,\n  )\n\n/**\n * Price data for token and ela based on block number\n */\nconst priceQueryConstructor = (subqueries: string[]) => {\n  return gql`\n    query tokenPriceData {\n      ${subqueries}\n    }\n  `\n}\n\nconst fetchTokenPriceData = async (\n  address: string,\n  interval: number,\n  startTimestamp: number,\n): Promise<{\n  data?: PriceChartEntry[]\n  error: boolean\n}> => {\n  // Construct timestamps to query against\n  const endTimestamp = getUnixTime(new Date())\n  const timestamps = []\n  let time = startTimestamp\n  while (time <= endTimestamp) {\n    timestamps.push(time)\n    time += interval\n  }\n  try {\n    const blocks = await getBlocksFromTimestamps(timestamps, 'asc', 500)\n    if (!blocks || blocks.length === 0) {\n      console.error('Error fetching blocks for timestamps', timestamps)\n      return {\n        error: false,\n      }\n    }\n\n    const prices: any | undefined = await multiQuery(\n      priceQueryConstructor,\n      getPriceSubqueries(address, blocks),\n      INFO_CLIENT,\n      200,\n    )\n\n    if (!prices) {\n      console.error('Price data failed to load')\n      return {\n        error: false,\n      }\n    }\n\n    // format token ELA price results\n    const tokenPrices: {\n      timestamp: string\n      derivedELA: number\n      priceUSD: number\n    }[] = []\n\n    // Get Token prices in ELA\n    Object.keys(prices).forEach((priceKey) => {\n      const timestamp = priceKey.split('t')[1]\n      // if its ELA price e.g. `b123` split('t')[1] will be undefined and skip ELA price entry\n      if (timestamp) {\n        tokenPrices.push({\n          timestamp,\n          derivedELA: prices[priceKey]?.derivedELA ? parseFloat(prices[priceKey].derivedELA) : 0,\n          priceUSD: 0,\n        })\n      }\n    })\n\n    // Go through ELA USD prices and calculate Token price based on it\n    Object.keys(prices).forEach((priceKey) => {\n      const timestamp = priceKey.split('b')[1]\n      // if its Token price e.g. `t123` split('b')[1] will be undefined and skip Token price entry\n      if (timestamp) {\n        const tokenPriceIndex = tokenPrices.findIndex((tokenPrice) => tokenPrice.timestamp === timestamp)\n        if (tokenPriceIndex >= 0) {\n          const { derivedELA } = tokenPrices[tokenPriceIndex]\n          tokenPrices[tokenPriceIndex].priceUSD = parseFloat(prices[priceKey]?.elaPrice ?? 0) * derivedELA\n        }\n      }\n    })\n\n    // graphql-request does not guarantee same ordering of batched requests subqueries, hence sorting by timestamp from oldest to newest\n    tokenPrices.sort((a, b) => parseInt(a.timestamp, 10) - parseInt(b.timestamp, 10))\n\n    const formattedHistory = []\n\n    // for each timestamp, construct the open and close price\n    for (let i = 0; i < tokenPrices.length - 1; i++) {\n      formattedHistory.push({\n        time: parseFloat(tokenPrices[i].timestamp),\n        open: tokenPrices[i].priceUSD,\n        close: tokenPrices[i + 1].priceUSD,\n        high: tokenPrices[i + 1].priceUSD,\n        low: tokenPrices[i].priceUSD,\n      })\n    }\n\n    return { data: formattedHistory, error: false }\n  } catch (error) {\n    console.error(`Failed to fetch price data for token ${address}`, error)\n    return {\n      error: true,\n    }\n  }\n}\n\nexport default fetchTokenPriceData\n","import { request, gql } from 'graphql-request'\nimport { INFO_CLIENT } from 'config/constants/endpoints'\nimport { TOKEN_BLACKLIST } from 'config/constants/info'\n\n/**\n * Data for showing Pools table on the Token page\n */\nconst POOLS_FOR_TOKEN = gql`\n  query poolsForToken($address: Bytes!, $blacklist: [String!]) {\n    asToken0: pairs(\n      first: 15\n      orderBy: trackedReserveELA\n      orderDirection: desc\n      where: { totalTransactions_gt: 100, token0: $address, token1_not_in: $blacklist }\n    ) {\n      id\n    }\n    asToken1: pairs(\n      first: 15\n      orderBy: trackedReserveELA\n      orderDirection: desc\n      where: { totalTransactions_gt: 100, token1: $address, token0_not_in: $blacklist }\n    ) {\n      id\n    }\n  }\n`\n\ninterface PoolsForTokenResponse {\n  asToken0: {\n    id: string\n  }[]\n  asToken1: {\n    id: string\n  }[]\n}\n\nconst fetchPoolsForToken = async (\n  address: string,\n): Promise<{\n  error: boolean\n  addresses?: string[]\n}> => {\n  try {\n    const data = await request<PoolsForTokenResponse>(INFO_CLIENT, POOLS_FOR_TOKEN, {\n      address,\n      blacklist: TOKEN_BLACKLIST,\n    })\n    return {\n      error: false,\n      addresses: data.asToken0.concat(data.asToken1).map((p) => p.id),\n    }\n  } catch (error) {\n    console.error(`Failed to fetch pools for token ${address}`, error)\n    return {\n      error: true,\n    }\n  }\n}\n\nexport default fetchPoolsForToken\n","import { useCallback, useEffect, useState, useMemo } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { getUnixTime, startOfHour, Duration, sub } from 'date-fns'\nimport { AppState, AppDispatch } from 'state'\nimport { isAddress } from 'utils'\nimport { Transaction } from 'state/info/types'\nimport fetchPoolChartData from 'state/info/queries/pools/chartData'\nimport fetchPoolTransactions from 'state/info/queries/pools/transactions'\nimport fetchTokenChartData from 'state/info/queries/tokens/chartData'\nimport fetchTokenTransactions from 'state/info/queries/tokens/transactions'\nimport fetchTokenPriceData from 'state/info/queries/tokens/priceData'\nimport fetchPoolsForToken from 'state/info/queries/tokens/poolsForToken'\nimport {\n  updateProtocolData,\n  updateProtocolChartData,\n  updateProtocolTransactions,\n  updatePoolData,\n  addPoolKeys,\n  updatePoolChartData,\n  updatePoolTransactions,\n  updateTokenData,\n  addTokenKeys,\n  addTokenPoolAddresses,\n  updateTokenChartData,\n  updateTokenPriceData,\n  updateTokenTransactions,\n} from './actions'\nimport { ProtocolData, PoolData, TokenData, ChartEntry, PriceChartEntry } from './types'\n\n// Protocol hooks\n\nexport const useProtocolData = (): [ProtocolData | undefined, (protocolData: ProtocolData) => void] => {\n  const protocolData: ProtocolData | undefined = useSelector((state: AppState) => state.info.protocol.overview)\n\n  const dispatch = useDispatch<AppDispatch>()\n  const setProtocolData: (protocolData: ProtocolData) => void = useCallback(\n    (data: ProtocolData) => dispatch(updateProtocolData({ protocolData: data })),\n    [dispatch],\n  )\n\n  return [protocolData, setProtocolData]\n}\n\nexport const useProtocolChartData = (): [ChartEntry[] | undefined, (chartData: ChartEntry[]) => void] => {\n  const chartData: ChartEntry[] | undefined = useSelector((state: AppState) => state.info.protocol.chartData)\n  const dispatch = useDispatch<AppDispatch>()\n  const setChartData: (chartData: ChartEntry[]) => void = useCallback(\n    (data: ChartEntry[]) => dispatch(updateProtocolChartData({ chartData: data })),\n    [dispatch],\n  )\n  return [chartData, setChartData]\n}\n\nexport const useProtocolTransactions = (): [Transaction[] | undefined, (transactions: Transaction[]) => void] => {\n  const transactions: Transaction[] | undefined = useSelector((state: AppState) => state.info.protocol.transactions)\n  const dispatch = useDispatch<AppDispatch>()\n  const setTransactions: (transactions: Transaction[]) => void = useCallback(\n    (transactionsData: Transaction[]) => dispatch(updateProtocolTransactions({ transactions: transactionsData })),\n    [dispatch],\n  )\n  return [transactions, setTransactions]\n}\n\n// Pools hooks\n\nexport const useAllPoolData = (): {\n  [address: string]: { data?: PoolData }\n} => {\n  return useSelector((state: AppState) => state.info.pools.byAddress)\n}\n\nexport const useUpdatePoolData = (): ((pools: PoolData[]) => void) => {\n  const dispatch = useDispatch<AppDispatch>()\n  return useCallback((pools: PoolData[]) => dispatch(updatePoolData({ pools })), [dispatch])\n}\n\nexport const useAddPoolKeys = (): ((addresses: string[]) => void) => {\n  const dispatch = useDispatch<AppDispatch>()\n  return useCallback((poolAddresses: string[]) => dispatch(addPoolKeys({ poolAddresses })), [dispatch])\n}\n\nexport const usePoolDatas = (poolAddresses: string[]): PoolData[] => {\n  const allPoolData = useAllPoolData()\n  const addNewPoolKeys = useAddPoolKeys()\n\n  const untrackedAddresses = poolAddresses.reduce((accum: string[], address) => {\n    if (!Object.keys(allPoolData).includes(address)) {\n      accum.push(address)\n    }\n    return accum\n  }, [])\n\n  useEffect(() => {\n    if (untrackedAddresses) {\n      addNewPoolKeys(untrackedAddresses)\n    }\n  }, [addNewPoolKeys, untrackedAddresses])\n\n  const poolsWithData = poolAddresses\n    .map((address) => {\n      return allPoolData[address]?.data\n    })\n    .filter((pool) => pool)\n\n  return poolsWithData\n}\n\nexport const usePoolChartData = (address: string): ChartEntry[] | undefined => {\n  const dispatch = useDispatch<AppDispatch>()\n  const pool = useSelector((state: AppState) => state.info.pools.byAddress[address])\n  const chartData = pool?.chartData\n  const [error, setError] = useState(false)\n\n  useEffect(() => {\n    const fetch = async () => {\n      const { error: fetchError, data } = await fetchPoolChartData(address)\n      if (!fetchError && data) {\n        dispatch(updatePoolChartData({ poolAddress: address, chartData: data }))\n      }\n      if (fetchError) {\n        setError(fetchError)\n      }\n    }\n    if (!chartData && !error) {\n      fetch()\n    }\n  }, [address, dispatch, error, chartData])\n\n  return chartData\n}\n\nexport const usePoolTransactions = (address: string): Transaction[] | undefined => {\n  const dispatch = useDispatch<AppDispatch>()\n  const pool = useSelector((state: AppState) => state.info.pools.byAddress[address])\n  const transactions = pool?.transactions\n  const [error, setError] = useState(false)\n\n  useEffect(() => {\n    const fetch = async () => {\n      const { error: fetchError, data } = await fetchPoolTransactions(address)\n      if (fetchError) {\n        setError(true)\n      } else {\n        dispatch(updatePoolTransactions({ poolAddress: address, transactions: data }))\n      }\n    }\n    if (!transactions && !error) {\n      fetch()\n    }\n  }, [address, dispatch, error, transactions])\n\n  return transactions\n}\n\n// Tokens hooks\n\nexport const useAllTokenData = (): {\n  [address: string]: { data?: TokenData }\n} => {\n  return useSelector((state: AppState) => state.info.tokens.byAddress)\n}\n\nexport const useUpdateTokenData = (): ((tokens: TokenData[]) => void) => {\n  const dispatch = useDispatch<AppDispatch>()\n  return useCallback(\n    (tokens: TokenData[]) => {\n      dispatch(updateTokenData({ tokens }))\n    },\n    [dispatch],\n  )\n}\n\nexport const useAddTokenKeys = (): ((addresses: string[]) => void) => {\n  const dispatch = useDispatch<AppDispatch>()\n  return useCallback((tokenAddresses: string[]) => dispatch(addTokenKeys({ tokenAddresses })), [dispatch])\n}\n\nexport const useTokenDatas = (addresses?: string[]): TokenData[] | undefined => {\n  const allTokenData = useAllTokenData()\n  const addNewTokenKeys = useAddTokenKeys()\n\n  // if token not tracked yet track it\n  addresses?.forEach((a) => {\n    if (!allTokenData[a]) {\n      addNewTokenKeys([a])\n    }\n  })\n\n  const tokensWithData = useMemo(() => {\n    if (!addresses) {\n      return undefined\n    }\n    return addresses\n      .map((a) => {\n        return allTokenData[a]?.data\n      })\n      .filter((token) => token)\n  }, [addresses, allTokenData])\n\n  return tokensWithData\n}\n\nexport const useTokenData = (address: string | undefined): TokenData | undefined => {\n  const allTokenData = useAllTokenData()\n  const addNewTokenKeys = useAddTokenKeys()\n\n  if (!address || !isAddress(address)) {\n    return undefined\n  }\n\n  // if token not tracked yet track it\n  if (!allTokenData[address]) {\n    addNewTokenKeys([address])\n  }\n\n  return allTokenData[address]?.data\n}\n\nexport const usePoolsForToken = (address: string): string[] | undefined => {\n  const dispatch = useDispatch<AppDispatch>()\n  const token = useSelector((state: AppState) => state.info.tokens.byAddress[address])\n  const poolsForToken = token.poolAddresses\n  const [error, setError] = useState(false)\n\n  useEffect(() => {\n    const fetch = async () => {\n      const { error: fetchError, addresses } = await fetchPoolsForToken(address)\n      if (!fetchError && addresses) {\n        dispatch(addTokenPoolAddresses({ tokenAddress: address, poolAddresses: addresses }))\n      }\n      if (fetchError) {\n        setError(fetchError)\n      }\n    }\n    if (!poolsForToken && !error) {\n      fetch()\n    }\n  }, [address, dispatch, error, poolsForToken])\n\n  return poolsForToken\n}\n\nexport const useTokenChartData = (address: string): ChartEntry[] | undefined => {\n  const dispatch = useDispatch<AppDispatch>()\n  const token = useSelector((state: AppState) => state.info.tokens.byAddress[address])\n  const { chartData } = token\n  const [error, setError] = useState(false)\n\n  useEffect(() => {\n    const fetch = async () => {\n      const { error: fetchError, data } = await fetchTokenChartData(address)\n      if (!fetchError && data) {\n        dispatch(updateTokenChartData({ tokenAddress: address, chartData: data }))\n      }\n      if (fetchError) {\n        setError(fetchError)\n      }\n    }\n    if (!chartData && !error) {\n      fetch()\n    }\n  }, [address, dispatch, error, chartData])\n\n  return chartData\n}\n\nexport const useTokenPriceData = (\n  address: string,\n  interval: number,\n  timeWindow: Duration,\n): PriceChartEntry[] | undefined => {\n  const dispatch = useDispatch<AppDispatch>()\n  const token = useSelector((state: AppState) => state.info.tokens.byAddress[address])\n  const priceData = token.priceData[interval]\n  const [error, setError] = useState(false)\n\n  // construct timestamps and check if we need to fetch more data\n  const oldestTimestampFetched = token.priceData.oldestFetchedTimestamp\n  const utcCurrentTime = getUnixTime(new Date()) * 1000\n  const startTimestamp = getUnixTime(startOfHour(sub(utcCurrentTime, timeWindow)))\n\n  useEffect(() => {\n    const fetch = async () => {\n      const { data, error: fetchingError } = await fetchTokenPriceData(address, interval, startTimestamp)\n      if (data) {\n        dispatch(\n          updateTokenPriceData({\n            tokenAddress: address,\n            secondsInterval: interval,\n            priceData: data,\n            oldestFetchedTimestamp: startTimestamp,\n          }),\n        )\n      }\n      if (fetchingError) {\n        setError(true)\n      }\n    }\n    if (!priceData && !error) {\n      fetch()\n    }\n  }, [address, dispatch, error, interval, oldestTimestampFetched, priceData, startTimestamp, timeWindow])\n\n  return priceData\n}\n\nexport const useTokenTransactions = (address: string): Transaction[] | undefined => {\n  const dispatch = useDispatch<AppDispatch>()\n  const token = useSelector((state: AppState) => state.info.tokens.byAddress[address])\n  const { transactions } = token\n  const [error, setError] = useState(false)\n\n  useEffect(() => {\n    const fetch = async () => {\n      const { error: fetchError, data } = await fetchTokenTransactions(address)\n      if (fetchError) {\n        setError(true)\n      } else if (data) {\n        dispatch(updateTokenTransactions({ tokenAddress: address, transactions: data }))\n      }\n    }\n    if (!transactions && !error) {\n      fetch()\n    }\n  }, [address, dispatch, error, transactions])\n\n  return transactions\n}\n","import { getUnixTime, subDays, subWeeks, startOfMinute } from 'date-fns'\nimport { request } from 'graphql-request'\n\n/**\n * Helper function to get large amount GraphQL subqueries\n * @param queryConstructor constructor function that combines subqueries\n * @param subqueries individual queries\n * @param endpoint GraphQL endpoint\n * @param skipCount how many subqueries to fire at a time\n * @returns\n */\nexport const multiQuery = async (\n  queryConstructor: (subqueries: string[]) => string,\n  subqueries: string[],\n  endpoint: string,\n  skipCount = 1000,\n) => {\n  let fetchedData = {}\n  let allFound = false\n  let skip = 0\n  try {\n    while (!allFound) {\n      let end = subqueries.length\n      if (skip + skipCount < subqueries.length) {\n        end = skip + skipCount\n      }\n      const subqueriesSlice = subqueries.slice(skip, end)\n      // eslint-disable-next-line no-await-in-loop\n      const result = await request(endpoint, queryConstructor(subqueriesSlice))\n      fetchedData = {\n        ...fetchedData,\n        ...result,\n      }\n      allFound = Object.keys(result).length < skipCount || skip + skipCount > subqueries.length\n      skip += skipCount\n    }\n    return fetchedData\n  } catch (error) {\n    console.error('Failed to fetch info data', error)\n    return null\n  }\n}\n\n/**\n * Returns UTC timestamps for 24h ago, 48h ago, 7d ago and 14d ago relative to current date and time\n */\nexport const getDeltaTimestamps = (): [number, number, number, number] => {\n  const utcCurrentTime = getUnixTime(new Date()) * 1000\n  const t24h = getUnixTime(startOfMinute(subDays(utcCurrentTime, 1)))\n  const t48h = getUnixTime(startOfMinute(subDays(utcCurrentTime, 2)))\n  const t7d = getUnixTime(startOfMinute(subWeeks(utcCurrentTime, 1)))\n  const t14d = getUnixTime(startOfMinute(subWeeks(utcCurrentTime, 2)))\n  return [t24h, t48h, t7d, t14d]\n}\n","import { ONE_DAY_UNIX, PCS_V2_START } from 'config/constants/info'\nimport { getUnixTime } from 'date-fns'\nimport { TransactionType } from 'state/info/types'\nimport { ChartEntry } from '../types'\nimport { MintResponse, SwapResponse, BurnResponse, TokenDayData, PairDayData, GlideDayData } from './types'\n\nexport const mapMints = (mint: MintResponse) => {\n  return {\n    type: TransactionType.MINT,\n    hash: mint.id.split('-')[0],\n    timestamp: mint.timestamp,\n    sender: mint.to,\n    token0Symbol: mint.pair.token0.symbol,\n    token1Symbol: mint.pair.token1.symbol,\n    token0Address: mint.pair.token0.id,\n    token1Address: mint.pair.token1.id,\n    amountUSD: parseFloat(mint.amountUSD),\n    amountToken0: parseFloat(mint.amount0),\n    amountToken1: parseFloat(mint.amount1),\n  }\n}\n\nexport const mapBurns = (burn: BurnResponse) => {\n  return {\n    type: TransactionType.BURN,\n    hash: burn.id.split('-')[0],\n    timestamp: burn.timestamp,\n    sender: burn.sender,\n    token0Symbol: burn.pair.token0.symbol,\n    token1Symbol: burn.pair.token1.symbol,\n    token0Address: burn.pair.token0.id,\n    token1Address: burn.pair.token1.id,\n    amountUSD: parseFloat(burn.amountUSD),\n    amountToken0: parseFloat(burn.amount0),\n    amountToken1: parseFloat(burn.amount1),\n  }\n}\n\nexport const mapSwaps = (swap: SwapResponse) => {\n  return {\n    type: TransactionType.SWAP,\n    hash: swap.id.split('-')[0],\n    timestamp: swap.timestamp,\n    sender: swap.from,\n    token0Symbol: swap.pair.token0.symbol,\n    token1Symbol: swap.pair.token1.symbol,\n    token0Address: swap.pair.token0.id,\n    token1Address: swap.pair.token1.id,\n    amountUSD: parseFloat(swap.amountUSD),\n    amountToken0: parseFloat(swap.amount0In) - parseFloat(swap.amount0Out),\n    amountToken1: parseFloat(swap.amount1In) - parseFloat(swap.amount1Out),\n  }\n}\n\nexport const mapDayData = (tokenDayData: TokenDayData | GlideDayData): ChartEntry => ({\n  date: tokenDayData.date,\n  volumeUSD: parseFloat(tokenDayData.dailyVolumeUSD),\n  liquidityUSD: parseFloat(tokenDayData.totalLiquidityUSD),\n})\n\nexport const mapPairDayData = (pairDayData: PairDayData): ChartEntry => ({\n  date: pairDayData.date,\n  volumeUSD: parseFloat(pairDayData.dailyVolumeUSD),\n  liquidityUSD: parseFloat(pairDayData.reserveUSD),\n})\n\ntype PoolOrTokenFetchFn = (skip: number, address: string) => Promise<{ data?: ChartEntry[]; error: boolean }>\ntype OverviewFetchFn = (skip: number) => Promise<{ data?: ChartEntry[]; error: boolean }>\n\n// Common helper function to retrieve chart data\n// Used for both Pool and Token charts\nexport const fetchChartData = async (\n  getEntityDayDatas: PoolOrTokenFetchFn | OverviewFetchFn,\n  address?: string,\n): Promise<{ data?: ChartEntry[]; error: boolean }> => {\n  let chartEntries: ChartEntry[] = []\n  let error = false\n  let skip = 0\n  let allFound = false\n\n  while (!allFound) {\n    // eslint-disable-next-line no-await-in-loop\n    const { data, error: fetchError } = await getEntityDayDatas(skip, address)\n    skip += 1000\n    allFound = data.length < 1000\n    error = fetchError\n    if (data) {\n      chartEntries = chartEntries.concat(data)\n    }\n  }\n\n  if (error || chartEntries.length === 0) {\n    return {\n      error: true,\n    }\n  }\n\n  const formattedDayDatas = chartEntries.reduce((accum: { [date: number]: ChartEntry }, dayData) => {\n    // At this stage we track unix day ordinal for each data point to check for empty days later\n    const dayOrdinal = parseInt((dayData.date / ONE_DAY_UNIX).toFixed(0))\n    return {\n      [dayOrdinal]: dayData,\n      ...accum,\n    }\n  }, {})\n\n  const availableDays = Object.keys(formattedDayDatas).map((dayOrdinal) => parseInt(dayOrdinal, 10))\n\n  const firstAvailableDayData = formattedDayDatas[availableDays[0]]\n  // fill in empty days ( there will be no day datas if no trades made that day )\n  let timestamp = firstAvailableDayData?.date ?? PCS_V2_START\n  let latestLiquidityUSD = firstAvailableDayData?.liquidityUSD ?? 0\n  const endTimestamp = getUnixTime(new Date())\n  while (timestamp < endTimestamp - ONE_DAY_UNIX) {\n    timestamp += ONE_DAY_UNIX\n    const dayOrdinal = parseInt((timestamp / ONE_DAY_UNIX).toFixed(0), 10)\n    if (!Object.keys(formattedDayDatas).includes(dayOrdinal.toString())) {\n      formattedDayDatas[dayOrdinal] = {\n        date: timestamp,\n        volumeUSD: 0,\n        liquidityUSD: latestLiquidityUSD,\n      }\n    } else {\n      latestLiquidityUSD = formattedDayDatas[dayOrdinal].liquidityUSD\n    }\n  }\n\n  return {\n    data: Object.values(formattedDayDatas),\n    error: false,\n  }\n}\n","import { gql } from 'graphql-request'\nimport { useState, useEffect } from 'react'\nimport { multiQuery } from 'views/Info/utils/infoQueryHelpers'\nimport { BLOCKS_CLIENT } from 'config/constants/endpoints'\nimport { Block } from 'state/info/types'\n\nconst getBlockSubqueries = (timestamps: number[]) =>\n  timestamps.map((timestamp) => {\n    return `t${timestamp}:blocks(first: 1, orderBy: timestamp, orderDirection: desc, where: { timestamp_gt: ${timestamp}, timestamp_lt: ${\n      timestamp + 600\n    } }) {\n      number\n    }`\n  })\n\nconst blocksQueryConstructor = (subqueries: string[]) => {\n  return gql`query blocks {\n    ${subqueries}\n  }`\n}\n\n/**\n * @notice Fetches block objects for an array of timestamps.\n * @param {Array} timestamps\n */\nexport const getBlocksFromTimestamps = async (\n  timestamps: number[],\n  sortDirection: 'asc' | 'desc' = 'desc',\n  skipCount = 500,\n): Promise<Block[]> => {\n  if (timestamps?.length === 0) {\n    return []\n  }\n\n  const fetchedData: any = await multiQuery(\n    blocksQueryConstructor,\n    getBlockSubqueries(timestamps),\n    BLOCKS_CLIENT,\n    skipCount,\n  )\n\n  const sortingFunction =\n    sortDirection === 'desc' ? (a: Block, b: Block) => b.number - a.number : (a: Block, b: Block) => a.number - b.number\n\n  const blocks: Block[] = []\n  if (fetchedData) {\n    // eslint-disable-next-line no-restricted-syntax\n    for (const key of Object.keys(fetchedData)) {\n      if (fetchedData[key].length > 0) {\n        blocks.push({\n          timestamp: key.split('t')[1],\n          number: parseInt(fetchedData[key][0].number, 10),\n        })\n      }\n    }\n    // graphql-request does not guarantee same ordering of batched requests subqueries, hence manual sorting\n    blocks.sort(sortingFunction)\n  }\n  return blocks\n}\n\n/**\n * for a given array of timestamps, returns block entities\n * @param timestamps\n * @param sortDirection\n * @param skipCount\n */\nexport const useBlocksFromTimestamps = (\n  timestamps: number[],\n  sortDirection: 'asc' | 'desc' = 'desc',\n  skipCount = 1000,\n): {\n  blocks?: Block[]\n  error: boolean\n} => {\n  const [blocks, setBlocks] = useState<Block[]>()\n  const [error, setError] = useState(false)\n\n  const timestampsString = JSON.stringify(timestamps)\n  const blocksString = blocks ? JSON.stringify(blocks) : undefined\n\n  useEffect(() => {\n    const fetchData = async () => {\n      const timestampsArray = JSON.parse(timestampsString)\n      const result = await getBlocksFromTimestamps(timestampsArray, sortDirection, skipCount)\n      if (result.length === 0) {\n        setError(true)\n      } else {\n        setBlocks(result)\n      }\n    }\n    const blocksArray = blocksString ? JSON.parse(blocksString) : undefined\n    if (!blocksArray && !error) {\n      fetchData()\n    }\n  }, [blocksString, error, skipCount, sortDirection, timestampsString])\n\n  return {\n    blocks,\n    error,\n  }\n}\n","export interface Block {\n  number: number\n  timestamp: string\n}\n\nexport interface ChartEntry {\n  date: number\n  volumeUSD: number\n  liquidityUSD: number\n}\n\n/**\n * Formatted type for Candlestick charts\n */\nexport interface PriceChartEntry {\n  time: number\n  open: number\n  close: number\n  high: number\n  low: number\n}\n\nexport enum TransactionType {\n  SWAP,\n  MINT,\n  BURN,\n}\n\nexport type Transaction = {\n  type: TransactionType\n  hash: string\n  timestamp: string\n  sender: string\n  token0Symbol: string\n  token1Symbol: string\n  token0Address: string\n  token1Address: string\n  amountUSD: number\n  amountToken0: number\n  amountToken1: number\n}\n\nexport interface ProtocolData {\n  volumeUSD: number\n  volumeUSDChange: number // in 24h, as percentage\n\n  liquidityUSD: number\n  liquidityUSDChange: number // in 24h, as percentage\n\n  txCount: number\n  txCountChange: number\n}\n\nexport interface ProtocolState {\n  readonly overview?: ProtocolData\n\n  readonly chartData?: ChartEntry[]\n\n  readonly transactions?: Transaction[]\n}\n\n// POOLS\n\nexport interface PoolData {\n  address: string\n\n  token0: {\n    name: string\n    symbol: string\n    address: string\n  }\n\n  token1: {\n    name: string\n    symbol: string\n    address: string\n  }\n\n  volumeUSD: number\n  volumeUSDChange: number\n  volumeUSDWeek: number\n  volumeUSDChangeWeek: number\n\n  totalFees24h: number\n  totalFees7d: number\n  lpFees24h: number\n  lpFees7d: number\n  lpApr7d: number\n\n  liquidityUSD: number\n  liquidityUSDChange: number\n\n  token0Price: number\n  token1Price: number\n\n  liquidityToken0: number\n  liquidityToken1: number\n}\n\nexport interface PoolsState {\n  byAddress: {\n    [address: string]: {\n      data?: PoolData\n      chartData?: ChartEntry[]\n      transactions?: Transaction[]\n    }\n  }\n}\n\n// TOKENS\n\nexport type TokenData = {\n  exists: boolean\n\n  name: string\n  symbol: string\n  address: string\n\n  volumeUSD: number\n  volumeUSDChange: number\n  volumeUSDWeek: number\n  txCount: number\n\n  liquidityToken: number\n  liquidityUSD: number\n  liquidityUSDChange: number\n\n  priceUSD: number\n  priceUSDChange: number\n  priceUSDChangeWeek: number\n}\n\nexport interface TokensState {\n  byAddress: {\n    [address: string]: {\n      data?: TokenData\n      poolAddresses?: string[]\n      chartData?: ChartEntry[]\n      priceData: {\n        oldestFetchedTimestamp?: number\n        [secondsInterval: number]: PriceChartEntry[] | undefined\n      }\n      transactions?: Transaction[]\n    }\n  }\n}\n\n// Info redux state\nexport interface InfoState {\n  protocol: ProtocolState\n  pools: PoolsState\n  tokens: TokensState\n}\n","import { TOTAL_FEE, LP_HOLDERS_FEE, WEEKS_IN_YEAR } from 'config/constants/info'\n\n/**\n * Get increase/decrease of value compared to the previous value (e.g. 24h volume compared to 24h volume the day before )\n * @param valueNow - more recent value\n * @param valueBefore - value to compare with\n */\nexport const getAmountChange = (valueNow?: number, valueBefore?: number) => {\n  if (valueNow && valueBefore) {\n    return valueNow - valueBefore\n  }\n  if (valueNow) {\n    return valueNow\n  }\n  return 0\n}\n\n/**\n * Get increase/decrease of value compared to the previous value as a percentage\n * @param valueNow - more recent value\n * @param valueBefore - value to compare with\n */\nexport const getPercentChange = (valueNow?: number, valueBefore?: number): number => {\n  if (valueNow && valueBefore) {\n    return ((valueNow - valueBefore) / valueBefore) * 100\n  }\n  return 0\n}\n\n/**\n * Given current value and value 1 and 2 periods (e.g. 1day + 2days, 1week - 2weeks) returns the amount change for latest period\n * and percentage change compared to the previous period.\n * @param valueNow - current value\n * @param valueOnePeriodAgo - value 1 period ago (e.g. 1 day or 1 week ago), period unit must be same as valueTwoPeriodsAgo\n * @param valueTwoPeriodsAgo - value 2 periods ago (e.g. 2 days or 2 weeks ago), period unit must be same as valueOnePeriodAgo\n * @returns amount change for the latest period and percentage change compared to previous period\n */\nexport const getChangeForPeriod = (\n  valueNow?: number,\n  valueOnePeriodAgo?: number,\n  valueTwoPeriodsAgo?: number,\n): [number, number] => {\n  const currentPeriodAmount = getAmountChange(valueNow, valueOnePeriodAgo)\n  const previousPeriodAmount = getAmountChange(valueOnePeriodAgo, valueTwoPeriodsAgo)\n  const percentageChange = getPercentChange(currentPeriodAmount, previousPeriodAmount)\n  return [currentPeriodAmount, percentageChange]\n}\n\nexport const getLpFeesAndApr = (volumeUSD: number, volumeUSDWeek: number, liquidityUSD: number) => {\n  const totalFees24h = volumeUSD * TOTAL_FEE\n  const totalFees7d = volumeUSDWeek * TOTAL_FEE\n  const lpFees24h = volumeUSD * LP_HOLDERS_FEE\n  const lpFees7d = volumeUSDWeek * LP_HOLDERS_FEE\n\n  const lpApr7d = liquidityUSD > 0 ? (volumeUSDWeek * LP_HOLDERS_FEE * WEEKS_IN_YEAR * 100) / liquidityUSD : 0\n  return {\n    totalFees24h,\n    totalFees7d,\n    lpFees24h,\n    lpFees7d,\n    lpApr7d: lpApr7d !== Infinity ? lpApr7d : 0,\n  }\n}\n","import { useState, useEffect } from 'react'\nimport { request, gql } from 'graphql-request'\nimport { INFO_CLIENT } from 'config/constants/endpoints'\nimport { getChangeForPeriod, getPercentChange } from 'views/Info/utils/infoDataHelpers'\nimport { ProtocolData } from 'state/info/types'\nimport { getDeltaTimestamps } from 'views/Info/utils/infoQueryHelpers'\nimport { useBlocksFromTimestamps } from 'views/Info/hooks/useBlocksFromTimestamps'\n\ninterface GlideFactory {\n  totalTransactions: string\n  totalVolumeUSD: string\n  totalLiquidityUSD: string\n}\n\ninterface OverviewResponse {\n  glideFactories: GlideFactory[]\n}\n\n/**\n * Latest Liquidity, Volume and Transaction count\n */\nconst getOverviewData = async (block?: number): Promise<{ data?: OverviewResponse; error: boolean }> => {\n  try {\n    const query = gql`query overview {\n      glideFactories(\n        ${block ? `block: { number: ${block}}` : ``} \n        first: 1) {\n        totalTransactions\n        totalVolumeUSD\n        totalLiquidityUSD\n      }\n    }`\n    const data = await request<OverviewResponse>(INFO_CLIENT, query)\n    return { data, error: false }\n  } catch (error) {\n    console.error('Failed to fetch info overview', error)\n    return { data: null, error: true }\n  }\n}\n\nconst formatGlideFactoryResponse = (rawGlideFactory?: GlideFactory) => {\n  if (rawGlideFactory) {\n    return {\n      totalTransactions: parseFloat(rawGlideFactory.totalTransactions),\n      totalVolumeUSD: parseFloat(rawGlideFactory.totalVolumeUSD),\n      totalLiquidityUSD: parseFloat(rawGlideFactory.totalLiquidityUSD),\n    }\n  }\n  return null\n}\n\ninterface ProtocolFetchState {\n  error: boolean\n  data?: ProtocolData\n}\n\nconst useFetchProtocolData = (): ProtocolFetchState => {\n  const [fetchState, setFetchState] = useState<ProtocolFetchState>({\n    error: false,\n  })\n  const [t24, t48] = getDeltaTimestamps()\n  const { blocks, error: blockError } = useBlocksFromTimestamps([t24, t48])\n  const [block24, block48] = blocks ?? []\n\n  useEffect(() => {\n    const fetch = async () => {\n      const { error, data } = await getOverviewData()\n      const { error: error24, data: data24 } = await getOverviewData(block24?.number ?? undefined)\n      const { error: error48, data: data48 } = await getOverviewData(block48?.number ?? undefined)\n      const anyError = error || error24 || error48\n      const overviewData = formatGlideFactoryResponse(data?.glideFactories?.[0])\n      const overviewData24 = formatGlideFactoryResponse(data24?.glideFactories?.[0])\n      const overviewData48 = formatGlideFactoryResponse(data48?.glideFactories?.[0])\n      const allDataAvailable = overviewData && overviewData24 && overviewData48\n      if (anyError || !allDataAvailable) {\n        setFetchState({\n          error: true,\n        })\n      } else {\n        const [volumeUSD, volumeUSDChange] = getChangeForPeriod(\n          overviewData.totalVolumeUSD,\n          overviewData24.totalVolumeUSD,\n          overviewData48.totalVolumeUSD,\n        )\n        const liquidityUSDChange = getPercentChange(overviewData.totalLiquidityUSD, overviewData24.totalLiquidityUSD)\n        // 24H transactions\n        const [txCount, txCountChange] = getChangeForPeriod(\n          overviewData.totalTransactions,\n          overviewData24.totalTransactions,\n          overviewData48.totalTransactions,\n        )\n        const protocolData: ProtocolData = {\n          volumeUSD,\n          volumeUSDChange: typeof volumeUSDChange === 'number' ? volumeUSDChange : 0,\n          liquidityUSD: overviewData.totalLiquidityUSD,\n          liquidityUSDChange,\n          txCount,\n          txCountChange,\n        }\n        setFetchState({\n          error: false,\n          data: protocolData,\n        })\n      }\n    }\n    const allBlocksAvailable = block24?.number && block48?.number\n    if (allBlocksAvailable && !blockError && !fetchState.data) {\n      fetch()\n    }\n  }, [block24, block48, blockError, fetchState])\n\n  return fetchState\n}\n\nexport default useFetchProtocolData\n","/* eslint-disable no-await-in-loop */\nimport { useState, useEffect } from 'react'\nimport { request, gql } from 'graphql-request'\nimport { INFO_CLIENT } from 'config/constants/endpoints'\nimport { PCS_V2_START } from 'config/constants/info'\nimport { ChartEntry } from 'state/info/types'\nimport { GlideDayDatasResponse } from '../types'\nimport { fetchChartData, mapDayData } from '../helpers'\n\n/**\n * Data for displaying Liquidity and Volume charts on Overview page\n */\nconst GLIDE_DAY_DATAS = gql`\n  query overviewCharts($startTime: Int!, $skip: Int!) {\n    glideDayDatas(first: 1000, skip: $skip, where: { date_gt: $startTime }, orderBy: date, orderDirection: asc) {\n      date\n      dailyVolumeUSD\n      totalLiquidityUSD\n    }\n  }\n`\n\nconst getOverviewChartData = async (skip: number): Promise<{ data?: ChartEntry[]; error: boolean }> => {\n  try {\n    const { glideDayDatas } = await request<GlideDayDatasResponse>(INFO_CLIENT, GLIDE_DAY_DATAS, {\n      startTime: PCS_V2_START,\n      skip,\n    })\n    const data = glideDayDatas.map(mapDayData)\n    return { data, error: false }\n  } catch (error) {\n    console.error('Failed to fetch overview chart data', error)\n    return { error: true }\n  }\n}\n\n/**\n * Fetch historic chart data\n */\nconst useFetchGlobalChartData = (): {\n  error: boolean\n  data: ChartEntry[] | undefined\n} => {\n  const [overviewChartData, setOverviewChartData] = useState<ChartEntry[] | undefined>()\n  const [error, setError] = useState(false)\n\n  useEffect(() => {\n    const fetch = async () => {\n      const { data } = await fetchChartData(getOverviewChartData)\n      if (data) {\n        setOverviewChartData(data)\n      } else {\n        setError(true)\n      }\n    }\n    if (!overviewChartData && !error) {\n      fetch()\n    }\n  }, [overviewChartData, error])\n\n  return {\n    error,\n    data: overviewChartData,\n  }\n}\n\nexport default useFetchGlobalChartData\n","import { request, gql } from 'graphql-request'\nimport { INFO_CLIENT } from 'config/constants/endpoints'\nimport { Transaction } from 'state/info/types'\nimport { MintResponse, SwapResponse, BurnResponse } from 'state/info/queries/types'\nimport { mapMints, mapBurns, mapSwaps } from 'state/info/queries/helpers'\n\n/**\n * Transactions for Transaction table on the Home page\n */\nconst GLOBAL_TRANSACTIONS = gql`\n  query overviewTransactions {\n    mints: mints(first: 33, orderBy: timestamp, orderDirection: desc) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      to\n      amount0\n      amount1\n      amountUSD\n    }\n    swaps: swaps(first: 33, orderBy: timestamp, orderDirection: desc) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      from\n      amount0In\n      amount1In\n      amount0Out\n      amount1Out\n      amountUSD\n    }\n    burns: burns(first: 33, orderBy: timestamp, orderDirection: desc) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      sender\n      amount0\n      amount1\n      amountUSD\n    }\n  }\n`\ninterface TransactionResults {\n  mints: MintResponse[]\n  swaps: SwapResponse[]\n  burns: BurnResponse[]\n}\n\nconst fetchTopTransactions = async (): Promise<Transaction[] | undefined> => {\n  try {\n    const data = await request<TransactionResults>(INFO_CLIENT, GLOBAL_TRANSACTIONS)\n\n    if (!data) {\n      return undefined\n    }\n\n    const mints = data.mints.map(mapMints)\n    const burns = data.burns.map(mapBurns)\n    const swaps = data.swaps.map(mapSwaps)\n\n    return [...mints, ...burns, ...swaps].sort((a, b) => {\n      return parseInt(b.timestamp, 10) - parseInt(a.timestamp, 10)\n    })\n  } catch {\n    return undefined\n  }\n}\n\nexport default fetchTopTransactions\n","import { useState, useEffect } from 'react'\nimport { request, gql } from 'graphql-request'\nimport { INFO_CLIENT } from 'config/constants/endpoints'\nimport { TOKEN_BLACKLIST } from 'config/constants/info'\nimport { getDeltaTimestamps } from 'views/Info/utils/infoQueryHelpers'\n\ninterface TopPoolsResponse {\n  pairDayDatas: {\n    id: string\n  }[]\n}\n\n/**\n * Initial pools to display on the home page\n */\nconst fetchTopPools = async (timestamp24hAgo: number): Promise<string[]> => {\n  try {\n    const query = gql`\n      query topPools($blacklist: [String!], $timestamp24hAgo: Int) {\n        pairDayDatas(\n          first: 30\n          where: { dailyTxns_gt: 0, token0_not_in: $blacklist, token1_not_in: $blacklist, date_gt: $timestamp24hAgo }\n          orderBy: dailyVolumeUSD\n          orderDirection: desc\n        ) {\n          id\n        }\n      }\n    `\n    const data = await request<TopPoolsResponse>(INFO_CLIENT, query, { blacklist: TOKEN_BLACKLIST, timestamp24hAgo })\n    // pairDayDatas id has compound id \"0xPOOLADDRESS-NUMBERS\", extracting pool address with .split('-')\n    return data.pairDayDatas.map((p) => p.id.split('-')[0])\n  } catch (error) {\n    console.error('Failed to fetch top pools', error)\n    return []\n  }\n}\n\n/**\n * Fetch top addresses by volume\n */\nconst useTopPoolAddresses = (): string[] => {\n  const [topPoolAddresses, setTopPoolAddresses] = useState([])\n  const [timestamp24hAgo] = getDeltaTimestamps()\n\n  useEffect(() => {\n    const fetch = async () => {\n      const addresses = await fetchTopPools(timestamp24hAgo)\n      setTopPoolAddresses(addresses)\n    }\n    if (topPoolAddresses.length === 0) {\n      fetch()\n    }\n  }, [topPoolAddresses, timestamp24hAgo])\n\n  return topPoolAddresses\n}\n\nexport default useTopPoolAddresses\n","/* eslint-disable no-param-reassign */\nimport { useEffect, useState } from 'react'\nimport { request, gql } from 'graphql-request'\nimport { INFO_CLIENT } from 'config/constants/endpoints'\nimport { getDeltaTimestamps } from 'views/Info/utils/infoQueryHelpers'\nimport { useBlocksFromTimestamps } from 'views/Info/hooks/useBlocksFromTimestamps'\nimport { PoolData } from 'state/info/types'\nimport { getChangeForPeriod, getLpFeesAndApr, getPercentChange } from 'views/Info/utils/infoDataHelpers'\n\ninterface PoolFields {\n  id: string\n  reserve0: string\n  reserve1: string\n  reserveUSD: string\n  volumeUSD: string\n  token0Price: string\n  token1Price: string\n  token0: {\n    id: string\n    symbol: string\n    name: string\n  }\n  token1: {\n    id: string\n    symbol: string\n    name: string\n  }\n}\n\ninterface FormattedPoolFields\n  extends Omit<PoolFields, 'volumeUSD' | 'reserveUSD' | 'reserve0' | 'reserve1' | 'token0Price' | 'token1Price'> {\n  volumeUSD: number\n  reserveUSD: number\n  reserve0: number\n  reserve1: number\n  token0Price: number\n  token1Price: number\n}\n\ninterface PoolsQueryResponse {\n  now: PoolFields[]\n  oneDayAgo: PoolFields[]\n  twoDaysAgo: PoolFields[]\n  oneWeekAgo: PoolFields[]\n  twoWeeksAgo: PoolFields[]\n}\n\n/**\n * Data for displaying pool tables (on multiple pages, used throughout the site)\n * Note: Don't try to refactor it to use variables, server throws error if blocks passed as undefined variable\n * only works if its hard-coded into query string\n */\nconst POOL_AT_BLOCK = (block: number | null, pools: string[]) => {\n  const blockString = block ? `block: {number: ${block}}` : ``\n  const addressesString = `[\"${pools.join('\",\"')}\"]`\n  return `pairs(\n    where: { id_in: ${addressesString} }\n    ${blockString}\n    orderBy: trackedReserveELA\n    orderDirection: desc\n  ) {\n    id\n    reserve0\n    reserve1\n    reserveUSD\n    volumeUSD\n    token0Price\n    token1Price\n    token0 {\n      id\n      symbol\n      name\n    }\n    token1 {\n      id\n      symbol\n      name\n    }\n  }`\n}\n\nconst fetchPoolData = async (\n  block24h: number,\n  block48h: number,\n  block7d: number,\n  block14d: number,\n  poolAddresses: string[],\n) => {\n  try {\n    const query = gql`\n      query pools {\n        now: ${POOL_AT_BLOCK(null, poolAddresses)}\n        oneDayAgo: ${POOL_AT_BLOCK(block24h, poolAddresses)}\n        twoDaysAgo: ${POOL_AT_BLOCK(block48h, poolAddresses)}\n        oneWeekAgo: ${POOL_AT_BLOCK(block7d, poolAddresses)}\n        twoWeeksAgo: ${POOL_AT_BLOCK(block14d, poolAddresses)}\n      }\n    `\n    const data = await request<PoolsQueryResponse>(INFO_CLIENT, query)\n    return { data, error: false }\n  } catch (error) {\n    console.error('Failed to fetch pool data', error)\n    return { error: true }\n  }\n}\n\n// Transforms pools into \"0xADDRESS: { ...PoolFields }\" format and cast strings to numbers\nconst parsePoolData = (pairs?: PoolFields[]) => {\n  if (!pairs) {\n    return {}\n  }\n  return pairs.reduce((accum: { [address: string]: FormattedPoolFields }, poolData) => {\n    const { volumeUSD, reserveUSD, reserve0, reserve1, token0Price, token1Price } = poolData\n    accum[poolData.id] = {\n      ...poolData,\n      volumeUSD: parseFloat(volumeUSD),\n      reserveUSD: parseFloat(reserveUSD),\n      reserve0: parseFloat(reserve0),\n      reserve1: parseFloat(reserve1),\n      token0Price: parseFloat(token0Price),\n      token1Price: parseFloat(token1Price),\n    }\n    return accum\n  }, {})\n}\n\ninterface PoolDatas {\n  error: boolean\n  data?: {\n    [address: string]: PoolData\n  }\n}\n\n/**\n * Fetch top pools by liquidity\n */\nconst usePoolDatas = (poolAddresses: string[]): PoolDatas => {\n  const [fetchState, setFetchState] = useState<PoolDatas>({ error: false })\n  const [t24h, t48h, t7d, t14d] = getDeltaTimestamps()\n  const { blocks, error: blockError } = useBlocksFromTimestamps([t24h, t48h, t7d, t14d])\n  const [block24h, block48h, block7d, block14d] = blocks ?? []\n\n  useEffect(() => {\n    const fetch = async () => {\n      const { error, data } = await fetchPoolData(\n        block24h.number,\n        block48h.number,\n        block7d.number,\n        block14d.number,\n        poolAddresses,\n      )\n      if (error) {\n        setFetchState({ error: true })\n      } else {\n        const formattedPoolData = parsePoolData(data?.now)\n        const formattedPoolData24h = parsePoolData(data?.oneDayAgo)\n        const formattedPoolData48h = parsePoolData(data?.twoDaysAgo)\n        const formattedPoolData7d = parsePoolData(data?.oneWeekAgo)\n        const formattedPoolData14d = parsePoolData(data?.twoWeeksAgo)\n\n        // Calculate data and format\n        const formatted = poolAddresses.reduce((accum: { [address: string]: PoolData }, address) => {\n          // Undefined data is possible if pool is brand new and didn't exist one day ago or week ago.\n          const current: FormattedPoolFields | undefined = formattedPoolData[address]\n          const oneDay: FormattedPoolFields | undefined = formattedPoolData24h[address]\n          const twoDays: FormattedPoolFields | undefined = formattedPoolData48h[address]\n          const week: FormattedPoolFields | undefined = formattedPoolData7d[address]\n          const twoWeeks: FormattedPoolFields | undefined = formattedPoolData14d[address]\n\n          const [volumeUSD, volumeUSDChange] = getChangeForPeriod(\n            current?.volumeUSD,\n            oneDay?.volumeUSD,\n            twoDays?.volumeUSD,\n          )\n          const [volumeUSDWeek, volumeUSDChangeWeek] = getChangeForPeriod(\n            current?.volumeUSD,\n            week?.volumeUSD,\n            twoWeeks?.volumeUSD,\n          )\n\n          const liquidityUSD = current ? current.reserveUSD : 0\n\n          const liquidityUSDChange = getPercentChange(current?.reserveUSD, oneDay?.reserveUSD)\n\n          const liquidityToken0 = current ? current.reserve0 : 0\n          const liquidityToken1 = current ? current.reserve1 : 0\n\n          const { totalFees24h, totalFees7d, lpFees24h, lpFees7d, lpApr7d } = getLpFeesAndApr(\n            volumeUSD,\n            volumeUSDWeek,\n            liquidityUSD,\n          )\n\n          if (current) {\n            accum[address] = {\n              address,\n              token0: {\n                address: current.token0.id,\n                name: current.token0.name,\n                symbol: current.token0.symbol,\n              },\n              token1: {\n                address: current.token1.id,\n                name: current.token1.name,\n                symbol: current.token1.symbol,\n              },\n              token0Price: current.token0Price,\n              token1Price: current.token1Price,\n              volumeUSD,\n              volumeUSDChange,\n              volumeUSDWeek,\n              volumeUSDChangeWeek,\n              totalFees24h,\n              totalFees7d,\n              lpFees24h,\n              lpFees7d,\n              lpApr7d,\n              liquidityUSD,\n              liquidityUSDChange,\n              liquidityToken0,\n              liquidityToken1,\n            }\n          }\n\n          return accum\n        }, {})\n        setFetchState({ data: formatted, error: false })\n      }\n    }\n\n    const allBlocksAvailable = block24h?.number && block48h?.number && block7d?.number && block14d?.number\n    if (poolAddresses.length > 0 && allBlocksAvailable && !blockError) {\n      fetch()\n    }\n  }, [poolAddresses, block24h, block48h, block7d, block14d, blockError])\n\n  return fetchState\n}\n\nexport default usePoolDatas\n","import { useBlocksFromTimestamps } from 'views/Info/hooks/useBlocksFromTimestamps'\nimport { getDeltaTimestamps } from 'views/Info/utils/infoQueryHelpers'\nimport { useState, useEffect } from 'react'\nimport { request, gql } from 'graphql-request'\nimport { INFO_CLIENT } from 'config/constants/endpoints'\n\nexport interface ElaPrices {\n  current: number\n  oneDay: number\n  twoDay: number\n  week: number\n}\n\nconst ELA_PRICES = gql`\n  query prices($block24: Int!, $block48: Int!, $blockWeek: Int!) {\n    current: bundle(id: \"1\") {\n      elaPrice\n    }\n    oneDay: bundle(id: \"1\", block: { number: $block24 }) {\n      elaPrice\n    }\n    twoDay: bundle(id: \"1\", block: { number: $block48 }) {\n      elaPrice\n    }\n    oneWeek: bundle(id: \"1\", block: { number: $blockWeek }) {\n      elaPrice\n    }\n  }\n`\n\ninterface PricesResponse {\n  current: {\n    elaPrice: string\n  }\n  oneDay: {\n    elaPrice: string\n  }\n  twoDay: {\n    elaPrice: string\n  }\n  oneWeek: {\n    elaPrice: string\n  }\n}\n\nconst fetchElaPrices = async (\n  block24: number,\n  block48: number,\n  blockWeek: number,\n): Promise<{ elaPrices: ElaPrices | undefined; error: boolean }> => {\n  try {\n    const data = await request<PricesResponse>(INFO_CLIENT, ELA_PRICES, {\n      block24,\n      block48,\n      blockWeek,\n    })\n    return {\n      error: false,\n      elaPrices: {\n        current: parseFloat(data.current?.elaPrice ?? '0'),\n        oneDay: parseFloat(data.oneDay?.elaPrice ?? '0'),\n        twoDay: parseFloat(data.twoDay?.elaPrice ?? '0'),\n        week: parseFloat(data.oneWeek?.elaPrice ?? '0'),\n      },\n    }\n  } catch (error) {\n    console.error('Failed to fetch ELA prices', error)\n    return {\n      error: true,\n      elaPrices: undefined,\n    }\n  }\n}\n\n/**\n * Returns ELA prices at current, 24h, 48h, and 7d intervals\n */\nexport const useElaPrices = (): ElaPrices | undefined => {\n  const [prices, setPrices] = useState<ElaPrices | undefined>()\n  const [error, setError] = useState(false)\n\n  const [t24, t48, tWeek] = getDeltaTimestamps()\n  const { blocks, error: blockError } = useBlocksFromTimestamps([t24, t48, tWeek])\n\n  useEffect(() => {\n    const fetch = async () => {\n      const [block24, block48, blockWeek] = blocks\n      const { elaPrices, error: fetchError } = await fetchElaPrices(block24.number, block48.number, blockWeek.number)\n      if (fetchError) {\n        setError(true)\n      } else {\n        setPrices(elaPrices)\n      }\n    }\n    if (!prices && !error && blocks && !blockError) {\n      fetch()\n    }\n  }, [error, prices, blocks, blockError])\n\n  return prices\n}\n","/* eslint-disable no-param-reassign */\nimport { useState, useEffect } from 'react'\nimport { request, gql } from 'graphql-request'\nimport { INFO_CLIENT } from 'config/constants/endpoints'\nimport { getDeltaTimestamps } from 'views/Info/utils/infoQueryHelpers'\nimport { useBlocksFromTimestamps } from 'views/Info/hooks/useBlocksFromTimestamps'\nimport { getPercentChange, getChangeForPeriod, getAmountChange } from 'views/Info/utils/infoDataHelpers'\nimport { TokenData } from 'state/info/types'\nimport { useElaPrices } from 'views/Info/hooks/useElaPrices'\n\ninterface TokenFields {\n  id: string\n  symbol: string\n  name: string\n  derivedELA: string // Price in ELA per token\n  derivedUSD: string // Price in USD per token\n  tradeVolumeUSD: string\n  totalTransactions: string\n  totalLiquidity: string\n}\n\ninterface FormattedTokenFields\n  extends Omit<TokenFields, 'derivedELA' | 'derivedUSD' | 'tradeVolumeUSD' | 'totalTransactions' | 'totalLiquidity'> {\n  derivedELA: number\n  derivedUSD: number\n  tradeVolumeUSD: number\n  totalTransactions: number\n  totalLiquidity: number\n}\n\ninterface TokenQueryResponse {\n  now: TokenFields[]\n  oneDayAgo: TokenFields[]\n  twoDaysAgo: TokenFields[]\n  oneWeekAgo: TokenFields[]\n  twoWeeksAgo: TokenFields[]\n}\n\n/**\n * Main token data to display on Token page\n */\nconst TOKEN_AT_BLOCK = (block: number | undefined, tokens: string[]) => {\n  const addressesString = `[\"${tokens.join('\",\"')}\"]`\n  const blockString = block ? `block: {number: ${block}}` : ``\n  return `tokens(\n      where: {id_in: ${addressesString}}\n      ${blockString}\n      orderBy: tradeVolumeUSD\n      orderDirection: desc\n    ) {\n      id\n      symbol\n      name\n      derivedELA\n      derivedUSD\n      tradeVolumeUSD\n      totalTransactions\n      totalLiquidity\n    }\n  `\n}\n\nconst fetchTokenData = async (\n  block24h: number,\n  block48h: number,\n  block7d: number,\n  block14d: number,\n  tokenAddresses: string[],\n) => {\n  try {\n    const query = gql`\n      query tokens {\n        now: ${TOKEN_AT_BLOCK(null, tokenAddresses)}\n        oneDayAgo: ${TOKEN_AT_BLOCK(block24h, tokenAddresses)}\n        twoDaysAgo: ${TOKEN_AT_BLOCK(block48h, tokenAddresses)}\n        oneWeekAgo: ${TOKEN_AT_BLOCK(block7d, tokenAddresses)}\n        twoWeeksAgo: ${TOKEN_AT_BLOCK(block14d, tokenAddresses)}\n      }\n    `\n    const data = await request<TokenQueryResponse>(INFO_CLIENT, query)\n    return { data, error: false }\n  } catch (error) {\n    console.error('Failed to fetch token data', error)\n    return { error: true }\n  }\n}\n\n// Transforms tokens into \"0xADDRESS: { ...TokenFields }\" format and cast strings to numbers\nconst parseTokenData = (tokens?: TokenFields[]) => {\n  if (!tokens) {\n    return {}\n  }\n  return tokens.reduce((accum: { [address: string]: FormattedTokenFields }, tokenData) => {\n    const { derivedELA, derivedUSD, tradeVolumeUSD, totalTransactions, totalLiquidity } = tokenData\n    accum[tokenData.id] = {\n      ...tokenData,\n      derivedELA: parseFloat(derivedELA),\n      derivedUSD: parseFloat(derivedUSD),\n      tradeVolumeUSD: parseFloat(tradeVolumeUSD),\n      totalTransactions: parseFloat(totalTransactions),\n      totalLiquidity: parseFloat(totalLiquidity),\n    }\n    return accum\n  }, {})\n}\n\ninterface TokenDatas {\n  error: boolean\n  data?: {\n    [address: string]: TokenData\n  }\n}\n\n/**\n * Fetch top addresses by volume\n */\nconst useFetchedTokenDatas = (tokenAddresses: string[]): TokenDatas => {\n  const [fetchState, setFetchState] = useState<TokenDatas>({ error: false })\n  const [t24h, t48h, t7d, t14d] = getDeltaTimestamps()\n  const { blocks, error: blockError } = useBlocksFromTimestamps([t24h, t48h, t7d, t14d])\n  const [block24h, block48h, block7d, block14d] = blocks ?? []\n  const elaPrices = useElaPrices()\n\n  useEffect(() => {\n    const fetch = async () => {\n      const { error, data } = await fetchTokenData(\n        block24h.number,\n        block48h.number,\n        block7d.number,\n        block14d.number,\n        tokenAddresses,\n      )\n      if (error) {\n        setFetchState({ error: true })\n      } else {\n        const parsed = parseTokenData(data?.now)\n        const parsed24 = parseTokenData(data?.oneDayAgo)\n        const parsed48 = parseTokenData(data?.twoDaysAgo)\n        const parsed7d = parseTokenData(data?.oneWeekAgo)\n        const parsed14d = parseTokenData(data?.twoWeeksAgo)\n\n        // Calculate data and format\n        const formatted = tokenAddresses.reduce((accum: { [address: string]: TokenData }, address) => {\n          const current: FormattedTokenFields | undefined = parsed[address]\n          const oneDay: FormattedTokenFields | undefined = parsed24[address]\n          const twoDays: FormattedTokenFields | undefined = parsed48[address]\n          const week: FormattedTokenFields | undefined = parsed7d[address]\n          const twoWeeks: FormattedTokenFields | undefined = parsed14d[address]\n\n          const [volumeUSD, volumeUSDChange] = getChangeForPeriod(\n            current?.tradeVolumeUSD,\n            oneDay?.tradeVolumeUSD,\n            twoDays?.tradeVolumeUSD,\n          )\n          const [volumeUSDWeek] = getChangeForPeriod(\n            current?.tradeVolumeUSD,\n            week?.tradeVolumeUSD,\n            twoWeeks?.tradeVolumeUSD,\n          )\n          const liquidityUSD = current ? current.totalLiquidity * current.derivedUSD : 0\n          const liquidityUSDOneDayAgo = oneDay ? oneDay.totalLiquidity * oneDay.derivedUSD : 0\n          const liquidityUSDChange = getPercentChange(liquidityUSD, liquidityUSDOneDayAgo)\n          const liquidityToken = current ? current.totalLiquidity : 0\n          // Prices of tokens for now, 24h ago and 7d ago\n          const priceUSD = current ? current.derivedELA * elaPrices.current : 0\n          const priceUSDOneDay = oneDay ? oneDay.derivedELA * elaPrices.oneDay : 0\n          const priceUSDWeek = week ? week.derivedELA * elaPrices.week : 0\n          const priceUSDChange = getPercentChange(priceUSD, priceUSDOneDay)\n          const priceUSDChangeWeek = getPercentChange(priceUSD, priceUSDWeek)\n          const txCount = getAmountChange(current?.totalTransactions, oneDay?.totalTransactions)\n\n          accum[address] = {\n            exists: !!current,\n            address,\n            name: current ? current.name : '',\n            symbol: current ? current.symbol : '',\n            volumeUSD,\n            volumeUSDChange,\n            volumeUSDWeek,\n            txCount,\n            liquidityUSD,\n            liquidityUSDChange,\n            liquidityToken,\n            priceUSD,\n            priceUSDChange,\n            priceUSDChangeWeek,\n          }\n\n          return accum\n        }, {})\n        setFetchState({ data: formatted, error: false })\n      }\n    }\n    const allBlocksAvailable = block24h?.number && block48h?.number && block7d?.number && block14d?.number\n    if (tokenAddresses.length > 0 && allBlocksAvailable && !blockError && elaPrices) {\n      fetch()\n    }\n  }, [tokenAddresses, block24h, block48h, block7d, block14d, blockError, elaPrices])\n\n  return fetchState\n}\n\nexport default useFetchedTokenDatas\n","import { useEffect, useState } from 'react'\nimport { request, gql } from 'graphql-request'\nimport { INFO_CLIENT } from 'config/constants/endpoints'\nimport { TOKEN_BLACKLIST } from 'config/constants/info'\nimport { getDeltaTimestamps } from 'views/Info/utils/infoQueryHelpers'\n\ninterface TopTokensResponse {\n  tokenDayDatas: {\n    id: string\n  }[]\n}\n\n/**\n * Tokens to display on Home page\n * The actual data is later requested in tokenData.ts\n * Note: dailyTxns_gt: 300 is there to prevent fetching incorrectly priced tokens with high dailyVolumeUSD\n */\nconst fetchTopTokens = async (timestamp24hAgo: number): Promise<string[]> => {\n  try {\n    const query = gql`\n      query topTokens($blacklist: [String!], $timestamp24hAgo: Int) {\n        tokenDayDatas(\n          first: 30\n          where: { dailyTxns_gt: 0, id_not_in: $blacklist, date_gt: $timestamp24hAgo }\n          orderBy: dailyVolumeUSD\n          orderDirection: desc\n        ) {\n          id\n        }\n      }\n    `\n    const data = await request<TopTokensResponse>(INFO_CLIENT, query, { blacklist: TOKEN_BLACKLIST, timestamp24hAgo })\n    // tokenDayDatas id has compound id \"0xTOKENADDRESS-NUMBERS\", extracting token address with .split('-')\n    return data.tokenDayDatas.map((t) => t.id.split('-')[0])\n  } catch (error) {\n    console.error('Failed to fetch top tokens', error)\n    return []\n  }\n}\n\n/**\n * Fetch top addresses by volume\n */\nconst useTopTokenAddresses = (): string[] => {\n  const [topTokenAddresses, setTopTokenAddresses] = useState([])\n  const [t24h] = getDeltaTimestamps()\n\n  useEffect(() => {\n    const fetch = async () => {\n      const addresses = await fetchTopTokens(t24h)\n      // console.log(addresses)\n      setTopTokenAddresses(addresses)\n    }\n    if (topTokenAddresses.length === 0) {\n      fetch()\n    }\n  }, [topTokenAddresses, t24h])\n\n  return topTokenAddresses\n}\n\nexport default useTopTokenAddresses\n","import React, { useEffect, useMemo } from 'react'\nimport useFetchProtocolData from 'state/info/queries/protocol/overview'\nimport useFetchGlobalChartData from 'state/info/queries/protocol/chart'\nimport fetchTopTransactions from 'state/info/queries/protocol/transactions'\nimport useTopPoolAddresses from 'state/info/queries/pools/topPools'\nimport usePoolDatas from 'state/info/queries/pools/poolData'\nimport useFetchedTokenDatas from 'state/info/queries/tokens/tokenData'\nimport useTopTokenAddresses from 'state/info/queries/tokens/topTokens'\nimport {\n  useProtocolData,\n  useProtocolChartData,\n  useProtocolTransactions,\n  useUpdatePoolData,\n  useAllPoolData,\n  useAddPoolKeys,\n  useAllTokenData,\n  useUpdateTokenData,\n  useAddTokenKeys,\n} from './hooks'\n\nexport const ProtocolUpdater: React.FC = () => {\n  const [protocolData, setProtocolData] = useProtocolData()\n  const { data: fetchedProtocolData, error } = useFetchProtocolData()\n\n  const [chartData, updateChartData] = useProtocolChartData()\n  const { data: fetchedChartData, error: chartError } = useFetchGlobalChartData()\n\n  const [transactions, updateTransactions] = useProtocolTransactions()\n\n  // update overview data if available and not set\n  useEffect(() => {\n    if (protocolData === undefined && fetchedProtocolData && !error) {\n      setProtocolData(fetchedProtocolData)\n    }\n  }, [error, fetchedProtocolData, protocolData, setProtocolData])\n\n  // update global chart data if available and not set\n  useEffect(() => {\n    if (chartData === undefined && fetchedChartData && !chartError) {\n      updateChartData(fetchedChartData)\n    }\n  }, [chartData, chartError, fetchedChartData, updateChartData])\n\n  useEffect(() => {\n    const fetch = async () => {\n      const data = await fetchTopTransactions()\n      if (data) {\n        updateTransactions(data)\n      }\n    }\n    if (!transactions) {\n      fetch()\n    }\n  }, [transactions, updateTransactions])\n\n  return null\n}\n\nexport const PoolUpdater: React.FC = () => {\n  const updatePoolData = useUpdatePoolData()\n  const addPoolKeys = useAddPoolKeys()\n\n  const allPoolData = useAllPoolData()\n  const addresses = useTopPoolAddresses()\n\n  // add top pools on first load\n  useEffect(() => {\n    if (addresses.length > 0) {\n      addPoolKeys(addresses)\n    }\n  }, [addPoolKeys, addresses])\n\n  // detect for which addresses we havent loaded pool data yet\n  const unfetchedPoolAddresses = useMemo(() => {\n    return Object.keys(allPoolData).reduce((accum: string[], address) => {\n      const poolData = allPoolData[address]\n      if (!poolData.data) {\n        accum.push(address)\n      }\n      return accum\n    }, [])\n  }, [allPoolData])\n\n  // fetch data for unfetched pools and update them\n  const { error: poolDataError, data: poolDatas } = usePoolDatas(unfetchedPoolAddresses)\n  useEffect(() => {\n    if (poolDatas && !poolDataError) {\n      updatePoolData(Object.values(poolDatas))\n    }\n  }, [poolDataError, poolDatas, updatePoolData])\n\n  return null\n}\n\nexport const TokenUpdater = (): null => {\n  const updateTokenDatas = useUpdateTokenData()\n  const addTokenKeys = useAddTokenKeys()\n\n  const allTokenData = useAllTokenData()\n  const addresses = useTopTokenAddresses()\n\n  // add top tokens on first load\n  useEffect(() => {\n    if (addresses.length > 0) {\n      addTokenKeys(addresses)\n    }\n  }, [addTokenKeys, addresses])\n\n  // detect for which addresses we havent loaded token data yet\n  const unfetchedTokenAddresses = useMemo(() => {\n    return Object.keys(allTokenData).reduce((accum: string[], key) => {\n      const tokenData = allTokenData[key]\n      if (!tokenData.data) {\n        accum.push(key)\n      }\n      return accum\n    }, [])\n  }, [allTokenData])\n\n  // console.log(unfetchedTokenAddresses)\n\n  // fetch data for unfetched tokens and update them\n  const { error: tokenDataError, data: tokenDatas } = useFetchedTokenDatas(unfetchedTokenAddresses)\n\n  useEffect(() => {\n    if (tokenDatas && !tokenDataError) {\n      updateTokenDatas(Object.values(tokenDatas))\n    }\n  }, [tokenDataError, tokenDatas, updateTokenDatas])\n\n  return null\n}\n"],"sourceRoot":""}